import numpy as np

def sim(confDict, demNodata, nav, xform, demData, gt):

    atStep  = confDict["facetParams"]["atstep"]
    ctStep  = confDict["facetParams"]["ctstep"]
    atDist  = confDict["facetParams"]["atdist"]
    ctDist  = confDict["facetParams"]["ctdist"]
    atNum   = atDist // atStep
    ctNum   = ctDist // ctStep

    # generate grid in xyz space
    gx, gy, gz = genGrid(nav, ctNum, atNum, atStep, ctStep)

    # Transform to DEM CRS and sample DEM
    gtx, gty, _ = xform.transform(gx, gy, gz)

    # sample DEM
    ix, iy  = gt * (gtx, gty)
    ix      = ix.astype(np.int32)
    iy      = iy.astype(np.int32)

    valid   = np.ones(ix.shape).astype(bool)
    demz    = np.zeros(ix.shape).astype(np.float32)

    valid[(ix < 0) | 
          (ix > (demData.shape[1] - 1)) | 
          (iy < 0) | 
          (iy > (demData.shape[0] - 1))] = False
    demz[valid]                          = demData[iy[valid], ix[valid]]

    # Mark nodata vals as invalid
    valid[demz == demNodata] = False

    # if there are no valid facets
    if np.sum(valid) == 0:
        return np.array([])

    # transform back to xyz for facet calcs
    sx, sy, sz = xform.transform(gtx, gty, demz, 
                                 direction="INVERSE")

    shape   = ((2 * int(atNum)) + 1, (2 * int(ctNum)) + 1)
    sx      = np.reshape(sx, shape)
    sy      = np.reshape(sy, shape)
    sz      = np.reshape(sz, shape)
    valid   = np.reshape(valid, shape)
    surface = np.stack((sx, sy, sz), 
                       axis=1)
    facets  = genFacets(surface, 
                        valid)

    # handle older config files without geometric spreading exponent - default to 4
    if "geometricexponent" in confDict["simParams"].keys():
        gspread = float(confDict["simParams"]["geometricexponent"])
    else:
        gspread = 4.0

    fcalc = calcFacetsFriis(facets,
                            nav["x"],
                            nav["y"],
                            nav["z"],
                            confDict["simParams"]["speedlight"],
                            gspread)

    if "dipole" in confDict["simParams"].keys() and confDict["simParams"]["dipole"]:
        fcalc = half_wave_dipole_gain(fcalc, 
                                      (nav["x"], nav["y"], nav["z"]), 
                                      nav["uv"])

    return fcalc

def half_wave_dipole_gain(fcalc, xant, uant):
    """
    Scale facet powers with half wave dipole gain pattern.

    Args:
        fcalc: Array generated by calcFacetsFriis with facet position and power information
        xant: (x, y, z) tuple with antenna position
        uant: Vector along dipole axis (zero gain in this direction)

    Returns:
        fcalc array with power column modified based on half wave dipole antenna pattern
    """

    # Copy fcalc to avoid modifying original
    fcalc_tmp = np.copy(fcalc[:, 4:7])

    # Translate coordinates to be centered on xant
    fcalc_tmp[:, 0] -= xant[0]
    fcalc_tmp[:, 1] -= xant[1]
    fcalc_tmp[:, 2] -= xant[2]

    # Find sin/cos of angle between dipole axis and vector to facet for dipole antenna pattern calc
    c = np.dot(fcalc_tmp, uant) / \
        (np.linalg.norm(fcalc_tmp, axis=1) * np.linalg.norm(uant))  # cosine of angle
    s = np.sqrt(1 - (c ** 2))  # sine of angle

    # Apply half wave dipole gain
    with np.errstate(divide="ignore"):
        fcalc[:, 0] *= (np.cos((np.pi / 2) * c) / s) ** 2

    # Fix s ~= 0 (0 deg or 180 deg)
    fcalc[np.abs(s) < 1e-4, 0] = 0

    return fcalc

def calcFacetsFriis(f, px, py, pz, c, gspread):
    """Calculate return power and twtt for facets using Friis-based
    model from Choudhary, Holt, Kempf 2016

    Args:
        f: Array with facet information
        px: Radar platform x coordinate
        py: Radar platform y coordinate
        pz: Radar platform z coordinate
        c: Speed of light
        gspread: Geometric spreading exponent

    """

    # Array to hold output data
    # Col 1 is power
    # Col 2 is two way travel time
    # Col 3 is whether the facet is to the right or left of the platform
    # Col 4 is a flag for whether to use the facet
    # Cols 5-7 hold x,y,z for the facet center
    # Col 8 holds the facet's cross track index
    fcalc = np.zeros((f.shape[0], 8))

    # Calc midpoints
    mx = (f[:, 0] + f[:, 3] + f[:, 6]) / 3
    my = (f[:, 1] + f[:, 4] + f[:, 7]) / 3
    mz = (f[:, 2] + f[:, 5] + f[:, 8]) / 3

    # Calc distances to platform/twtt
    rx = px - mx
    ry = py - my
    rz = pz - mz

    r = np.sqrt((rx ** 2) + (ry ** 2) + (rz ** 2))

    ## Calc area and normal vector
    # Calc 2->1 vector
    f[:, 3] = f[:, 0] - f[:, 3]  # x
    f[:, 4] = f[:, 1] - f[:, 4]  # y
    f[:, 5] = f[:, 2] - f[:, 5]  # z
    # Calc 1->3 vector
    f[:, 0] = f[:, 6] - f[:, 0]  # x
    f[:, 1] = f[:, 7] - f[:, 1]  # y
    f[:, 2] = f[:, 8] - f[:, 2]  # z
    # Calc cross product
    f[:, 6:9]   = np.cross(f[:, 3:6], f[:, 0:3])
    area        = np.sqrt((f[:, 6] ** 2) + (f[:, 7] ** 2) + (f[:, 8] ** 2)) / 2

    ## Calc power
    # Dot product between facet center -> platform and normal to facet
    ct = ((rx * f[:, 6]) + (ry * f[:, 7]) + (rz * f[:, 8])) / (r * area * 2)
    
    fcalc[:, 0] = np.abs(((area * ct) ** 2) / (r ** gspread))  # power
    fcalc[:, 1] = 2 * r / c  # twtt
    fcalc[:, 2] = f[:, 10]  # right or left
    fcalc[:, 3] = 1 # use all facets for now
    fcalc[:, 4] = mx # Facet centers
    fcalc[:, 5] = my
    fcalc[:, 6] = mz
    fcalc[:, 7] = f[:, 11]  # Cross track indices for echo power map

    return fcalc

def genGrid(nav, ctNum, atNum, atStep, ctStep):

    # Use meshgrid to come up with vectors to grid points
    mgrd = np.meshgrid(np.arange(-ctNum, ctNum + 1), 
                       np.arange(atNum, -atNum - 1, -1))

    # Generate XYZ grid
    ua = nav["uv"] * atStep # along track vector (forward)
    uc = nav["ul"] * ctStep # cross track vector (right)

    # Add vectors to nav points to get grid
    gx = (mgrd[1] * ua[0]) + (mgrd[0] * uc[0]) + nav["x"]
    gy = (mgrd[1] * ua[1]) + (mgrd[0] * uc[1]) + nav["y"]
    gz = (mgrd[1] * ua[2]) + (mgrd[0] * uc[2]) + nav["z"]

    return gx.flatten(), gy.flatten(), gz.flatten()

def genFacets(s, valid):
    # Generate list of facets (f) from surface grid (s)
    # Facets that contain a point that is not valid will not be evaluated later
    h = s.shape[1]
    w = s.shape[2]
    
    nfacet = (w - 1) * (h - 1) * 2  # number of facets
    qt = int(nfacet / 4)  # quarter
    hf = int(nfacet / 2)  # half
    tq = hf + qt  # three quarters

    # Array to hold facet data
    # Cols 1-9 hold (x1,y1,z1,x2,...,z3) of the facet corners
    # Col 10 holds whether the facet is valid and should be evaluated
    # Col 11 holds whether the facet is left or right side left is 0, right is 1
    # Col 12 holds the cross-track index of the facet. This is for the echo power map
    f       = np.zeros((nfacet, 12))
    fkeep   = np.ones(nfacet).astype(bool)

    # Ordering of points along axis 1 is important for cross product later
    # Ordering of points along axis 0 is important for left/right side

    atSlices = [slice(0, h - 1),
                slice(0, h - 1),
                slice(1, h),
                slice(1, h),
                slice(1, h),
                slice(0, h - 1),
                slice(0, h - 1),
                slice(0, h - 1),
                slice(1, h),
                slice(1, h),
                slice(1, h),
                slice(0, h - 1)]

    ctSlices = [slice(0, (w - 1) // 2),
                slice(1, (w + 1) // 2),
                slice(0, (w - 1) // 2),
                slice(1, (w + 1) // 2),
                slice(0, (w - 1) // 2),
                slice(1, (w + 1) // 2),
                slice((w - 1) // 2, w - 1),
                slice((w + 1) // 2, w),
                slice((w - 1) // 2, w - 1),
                slice((w + 1) // 2, w),
                slice((w - 1) // 2, w - 1),
                slice((w + 1) // 2, w)]

    lstSlices = [slice(0, qt), slice(qt, hf), slice(hf, tq), slice(tq, nfacet)]

    for i in range(4):
        for j in range(3):
            f[lstSlices[i], 3 * j]          = s[0, atSlices[(i * 3) + j], ctSlices[(i * 3) + j]].flatten() # X
            f[lstSlices[i], (3 * j) + 1]    = s[1, atSlices[(i * 3) + j], ctSlices[(i * 3) + j]].flatten() # Y
            f[lstSlices[i], (3 * j) + 2]    = s[2, atSlices[(i * 3) + j], ctSlices[(i * 3) + j]].flatten() # Z
            fkeep[lstSlices[i]]             &= valid[atSlices[(i * 3) + j], ctSlices[(i * 3) + j]].flatten()

    # Add in lr entry - l=0, r=1
    f[0:hf, 10]         = 0
    f[hf:nfacet, 10]    = 1

    # Add in cross track indices for echo power map
    hm0             = np.arange(0, h - 1)
    wm0             = np.arange(0, (w - 1) // 2)
    wm0, hm0        = np.meshgrid(wm0, hm0)
    f[0:qt, 11]     = wm0.flatten()
    f[qt:hf, 11]    = wm0.flatten()

    hm1                 = np.arange(0, h - 1)
    wm1                 = np.arange((w - 1) // 2, w - 1)
    wm1, hm1            = np.meshgrid(wm1, hm1)
    f[hf:tq, 11]        = wm1.flatten()
    f[tq:nfacet, 11]    = wm1.flatten()

    return f[fkeep]